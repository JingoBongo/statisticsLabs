# -*- coding: utf-8 -*-
"""Diabetes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xYoCwLxYNSa0mcF6vBo-6xQFnhuTnML5
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

dataset = pd.read_csv('diabetes.csv')
dataset.head()

"""To learn the dimensions of your dataset use the *shape* command """

dataset.shape

"""To find out only the number of rows (observations) use the *len* command or *shape[0]*"""

len(dataset)

dataset.shape[0]

"""To list the names of the variables use the *columns* command."""

dataset.columns

"""If you want it names of columns to be displayed as a list type rather than index type use *columns.tolist()*"""

dataset.columns.tolist()

"""To learn about the types of our variables us the 
*dtypes* command
"""

dataset.dtypes

"""To learn summary statistics and inspect the variables run the *describe* command"""

dataset.describe()

"""The variable "Outcome" takes the value of 1 if someone is Diabetes positive and zero otherwise. Its type should not be integer. Change it to Category by using the *astype* ."""

dataset["Outcome"] = dataset["Outcome"].astype('category')
dataset.dtypes

"""To make nicer charts and plots create a new variable 'Outcome2' that substitutes the 0/1 records in the Outcome with 'Diabetes Positive' and 'Diabetes Negative'."""

dataset['Outcome2'] = dataset['Outcome'].map({True: 'Diabetes Positive', False: 'Diabetes Negative'})

dataset.head()

"""Use describe once again to have a closer look at your data. Do any values of the variables raise questions? (e.g. zero values for BMI or Glucose)"""

dataset.describe()

"""Build the histograms of your variables to see how the variables' values are distributed. 
Notice the zero values for Variables like BMI, Glucose, Blood Pressure, Skin Thickness.
"""

dataset.hist(alpha=0.5, figsize=(20, 10))
plt.tight_layout()

"""Replace the zero values for the four variables for which these values are probably missing values with 'NaN'. Do not replace with means right away, because the means will be computed before replacing the zeroes with NaN and thus will be skewed."""

dataset['Glucose']=dataset['Glucose'].replace(0, np.nan)
dataset['BloodPressure']=dataset['BloodPressure'].replace(0, np.nan)
dataset['SkinThickness']=dataset['SkinThickness'].replace(0, np.nan)
dataset['BMI']=dataset['BMI'].replace(0, np.nan)

"""Check if zero values in relevant variables dissapeard by graphing again the histograms  """

dataset.hist(alpha=0.5, figsize=(20, 10))
plt.tight_layout()

"""Another way to check if there are any zero values left in relevant variables"""

(dataset['Glucose'] == 0).sum()

(dataset['BloodPressure'] == 0).sum()

(dataset['SkinThickness'] == 0).sum()

(dataset['BMI'] == 0).sum()

"""Now inspect once again the statistics of variables after zero values have been removed. Check how min, mean, medians have changed."""

dataset.describe()

"""Before deciding what values to enter instead of the NaN values check for skewness. Decide if mean or median is apropriate, or drop observations with NaN alltogether"""

stats_df=dataset.describe()
stats_df.loc['range'] = stats_df.loc['max'] - stats_df.loc['min']
stats_df.loc['skewness'] = dataset.skew()
stats_df.loc['kurtosis'] = dataset.kurt()
stats_df

dataset.columns.tolist()

"""None of the variables that contain NaN are highly skewed (-1> skew >1) so go ahead and fill in for the NaN values with respective variables' means"""

dataset['Glucose'] = dataset['Glucose'].fillna(dataset['Glucose'].mean())
dataset['BloodPressure'] = dataset['BloodPressure'].fillna(dataset['BloodPressure'].mean())
dataset['SkinThickness'] = dataset['SkinThickness'].fillna(dataset['SkinThickness'].mean())
dataset['BMI'] = dataset['BMI'].fillna(dataset['BMI'].mean())

"""The second value of SkinThickness was NaN, check if the value was replaced with the mean of SkinThickness by looking at the mean and printing the variable to check the second row """

dataset.loc[:, 'SkinThickness'].mean()

print(dataset[['SkinThickness']])

"""Inspect the histograms after all necessary changes have been made to variables. Note things such as the distribution shapes, how dispersed they are, how skewed they are, etc."""

dataset.hist(alpha=0.5, figsize=(20, 10))
plt.tight_layout()

"""Check out if the means of the variables differ a lot for those with diabetes and those with no diabetes"""

dataset.groupby('Outcome2').mean()

"""To check other statistics differentiated for those with and without diabetes use the *agg* command"""

dataset.groupby('Outcome2').agg(['mean', 'median', 'min',  'max', 'skew'])

"""You can check out whether the distributions of variables differ for those with diabetes and without"""

dataset['BMI'].hist(by=dataset['Outcome2'])

dataset['Glucose'].hist(by=dataset['Outcome2'])

"""It is difficult to infer if the distributions and the summary statistics differ for those with diabetes versus those without, so lets use box plots instead. Box plots will give you a better understanding about relevant memoments of the distributions for diabetes positive versus negative as they are great when one needs to compare two or more distributions.
Be aware that you have to indicate that the plots should not share the y axis as the units of measurement are all different for different variables. For that use sharey=False and indicate 8 different axes as shown below.

Inspect the box plots, note such things as their position (is one distribution higher placed than the other? what does it mean), compare their meadians, how dispersed they are by looking at their interquantile ranges, wiskers, and are there any/many outliers (remeber when modeling data, you will have to decide what to do with the outliers, so notice things like - how many outliers you have, but more importantly how extreme they  - extreme outliers will most probably have to be dealt with when cleaning the data).
"""

fig, axs = plt.subplots(8, figsize=(5,  30), sharey=False)
dataset.boxplot(['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI', 'DiabetesPedigreeFunction','Age'],
                'Outcome2', axs)
plt.tight_layout()

"""**NOW LETS MOVE TO CORRELATIONS BETWEE OUR VARIABLES**

I first plotted the BMI against Outcome2, but since Outcome2 is not an interval variable, these is nothing interesting a scatter plot will show us
"""

plt.scatter(dataset.Outcome2, dataset.BMI)

"""Let's check other variable correlations, for example Glucose and BMI. From the scatter plot below it doesn't look like there is a strong correlation between the two."""

plt.scatter(dataset.Glucose, dataset.BMI)

"""Maybe there is some correlations between BMI and Blood Pressure, but it's not very obvious"""

plt.scatter(dataset.BloodPressure, dataset.BMI)

"""There seems to be a positive correlations between Skin Thickness and BMI"""

plt.scatter(dataset.SkinThickness, dataset.BMI)

"""To make the plot look nicer and have the axes automatically appear on the plot you can use the scatterplot from the seaborn library """

import seaborn as sns
sns.scatterplot(x="SkinThickness", y="BMI", data=dataset);

"""To see the correlation between BMI and SkinThickness you can compute the variance covariance matrix for the two variables. The covariance is positive, so there is a positive relationship between the two.
Note: If you want just the covariance coefficient use the covariance function from the statistics library
"""

np.cov(dataset.BMI, dataset.SkinThickness)

"""Because we can't infer much about the strength of the correlation between the two variables from covariance let's compute the correlation coefficient instead.
Looking at the coefficient below one can conclude that there is some correlation between the two, but not super strong. 
"""

np.corrcoef(dataset.BMI, dataset.SkinThickness)

"""You can inspect that variance covariance matrix for all variables to see whether the variables have positive corelations or negative. However you cannot judge on the strength of these relationships."""

dataset.cov()

"""We can take a look at how variables vary together by building scatter plots for each pair of variables.
The only two relatively obvious corelations that come out of the scatter plots are those between 1)Glucose and Insulin and 2) BMI and Skin Thickness
"""

sns.set_context('talk')
sns.pairplot(dataset);

"""Add hue='Outcome2' to have the data points that belong to those diagnosed with diabetes in orange and for those with no diabetes in blue.
Looking at the plot we see some noise, especially for the Pregnacies variable. The obvious segregation can be made for the Glucose variable -- the orange dots seems to be higher than the blue dots, which suggests that glucose levels are elevated for those with diabetes (not surprising).
We do see some segregation for the other variables as well, which would imply that these variables have some connections to diabetes, however here we see the data only in two dimensions and it is difficult to say a lot. The correlations seem to be more complex where maybe combinations of tree variables would give us a better picture (eg. BMI alone may not be a good predictor for diabetes, but BMI and a high value of Diabetes Pedigree function together could predict diebestes - this is only an example though and futher investigation would be required to conclude better).
"""

sns.set_context('paper')
sns.pairplot(dataset, hue='Outcome2');

"""Heatmaps are great instruments to inspect the correlations between variables in a two dimensional space."""

sns.heatmap(corr)

"""Let's make the heat map nicer."""

sns.heatmap(corr, vmin=-1, vmax=1, center=0, cmap=sns.diverging_palette(20, 220, n=200),
             square=True)

"""You can also change the angle of the x axis ticks.

The heatmaps tell you how two variables are correlated. The color tells about the sign of the correlation and the intensity about the strength of the correlation.
The strongest correlations seem to be between Age and Pregnacies, SkinThickness and BMI and somewhat Insulin and Glucose. The heatmap confirms our earlier conclusions.
"""

corr = dataset.corr()
ax = sns.heatmap(
    corr, 
    vmin=-1, vmax=1, center=0,
    cmap=sns.diverging_palette(20, 220, n=200),
    square=True
)
ax.set_xticklabels(
    ax.get_xticklabels(),
    rotation=45,
    horizontalalignment='right'
);